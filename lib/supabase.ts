/**
 * Supabase Database Client and Service Layer
 * 
 * This module provides a configured Supabase client and a comprehensive service layer
 * for managing prompt recommendations in the database. It includes CRUD operations,
 * search functionality, and user-specific queries.
 */

import { createClient } from '@supabase/supabase-js';

// Initialize Supabase client with environment variables
const supabaseUrl = process.env.SUPABASE_URL!;
const supabaseAnonKey = process.env.SUPABASE_ANON_KEY!;

/**
 * Supabase client instance configured with project URL and anonymous key
 * Used for all database operations throughout the application
 */
export const supabase = createClient(supabaseUrl, supabaseAnonKey);

// TypeScript interfaces for type-safe database operations

/**
 * Complete recommendation record as stored in the database
 * Includes all fields returned from database queries
 */
export interface Recommendation {
  id?: string;              // Auto-generated UUID primary key
  domain: string;           // User's business domain/focus area
  prompt: string;           // The recommended prompt text
  explanation: string;      // AI-generated explanation of relevance
  similarity: number;       // Cosine similarity score (0-1)
  user_email?: string;      // Email of user who generated this recommendation
  created_at?: string;      // Timestamp when recommendation was created
}

/**
 * Data structure for inserting new recommendations
 * Some fields (id, created_at) are auto-generated by the database
 */
export interface RecommendationInsert {
  domain: string;           // Required: User's business domain
  prompt: string;           // Required: The recommended prompt
  explanation: string;      // Required: Explanation of relevance
  similarity: number;       // Required: Similarity score
  user_email?: string;      // Optional: User identifier for tracking
}

/**
 * Comprehensive service layer for recommendation database operations
 * Provides type-safe methods for all CRUD operations and specialized queries
 */
export const recommendationsService = {
  
  /**
   * Creates a single recommendation in the database
   * 
   * @param recommendation - The recommendation data to insert
   * @returns Promise resolving to the created recommendation or null if failed
   */
  async create(recommendation: RecommendationInsert): Promise<Recommendation | null> {
    try {
      const { data, error } = await supabase
        .from('recommendations')
        .insert(recommendation)
        .select()                    // Return the inserted record
        .single();                   // Expect exactly one record

      if (error) {
        console.error('Error creating recommendation:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Failed to create recommendation:', error);
      return null;
    }
  },

  /**
   * Creates multiple recommendations in a single database transaction
   * More efficient than individual inserts for batch operations
   * 
   * @param recommendations - Array of recommendation data to insert
   * @returns Promise resolving to array of created recommendations or null if failed
   */
  async createMany(recommendations: RecommendationInsert[]): Promise<Recommendation[] | null> {
    try {
      const { data, error } = await supabase
        .from('recommendations')
        .insert(recommendations)
        .select();                   // Return all inserted records

      if (error) {
        console.error('Error creating recommendations:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Failed to create recommendations:', error);
      return null;
    }
  },

  /**
   * Retrieves all recommendations for a specific domain
   * Ordered by similarity score (highest first)
   * 
   * @param domain - The domain to filter by
   * @returns Promise resolving to array of recommendations or null if failed
   */
  async getByDomain(domain: string): Promise<Recommendation[] | null> {
    try {
      const { data, error } = await supabase
        .from('recommendations')
        .select('*')
        .eq('domain', domain)
        .order('similarity', { ascending: false });

      if (error) {
        console.error('Error fetching recommendations:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Failed to fetch recommendations:', error);
      return null;
    }
  },

  /**
   * Retrieves all recommendations for a specific user
   * Ordered by creation date (newest first) for chronological history
   * 
   * @param userEmail - The user's email address
   * @returns Promise resolving to array of user's recommendations or null if failed
   */
  async getByUserEmail(userEmail: string): Promise<Recommendation[] | null> {
    try {
      const { data, error } = await supabase
        .from('recommendations')
        .select('*')
        .eq('user_email', userEmail)
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching user recommendations:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Failed to fetch user recommendations:', error);
      return null;
    }
  },

  /**
   * Retrieves all recommendations from the database
   * Ordered by creation date (newest first)
   * Use with caution on large datasets
   * 
   * @returns Promise resolving to array of all recommendations or null if failed
   */
  async getAll(): Promise<Recommendation[] | null> {
    try {
      const { data, error } = await supabase
        .from('recommendations')
        .select('*')
        .order('created_at', { ascending: false });

      if (error) {
        console.error('Error fetching all recommendations:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Failed to fetch all recommendations:', error);
      return null;
    }
  },

  /**
   * Retrieves recommendations with pagination support
   * Useful for large datasets and infinite scroll implementations
   * 
   * @param page - Page number (0-based)
   * @param limit - Number of records per page
   * @returns Promise resolving to paginated data and total count
   */
  async getPaginated(
    page: number = 0, 
    limit: number = 10
  ): Promise<{ data: Recommendation[] | null, count: number | null }> {
    try {
      const from = page * limit;        // Calculate offset
      const to = from + limit - 1;      // Calculate end range (inclusive)

      const { data, error, count } = await supabase
        .from('recommendations')
        .select('*', { count: 'exact' })    // Include total count
        .order('created_at', { ascending: false })
        .range(from, to);                   // Apply pagination

      if (error) {
        console.error('Error fetching paginated recommendations:', error);
        throw error;
      }

      return { data, count };
    } catch (error) {
      console.error('Failed to fetch paginated recommendations:', error);
      return { data: null, count: null };
    }
  },

  /**
   * Retrieves top recommendations for a domain by similarity score
   * Useful for showing the most relevant recommendations
   * 
   * @param domain - The domain to filter by
   * @param limit - Maximum number of recommendations to return
   * @returns Promise resolving to array of top recommendations or null if failed
   */
  async getTopByDomain(
    domain: string, 
    limit: number = 5
  ): Promise<Recommendation[] | null> {
    try {
      const { data, error } = await supabase
        .from('recommendations')
        .select('*')
        .eq('domain', domain)
        .order('similarity', { ascending: false })
        .limit(limit);

      if (error) {
        console.error('Error fetching top recommendations:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Failed to fetch top recommendations:', error);
      return null;
    }
  },

  /**
   * Deletes a single recommendation by its ID
   * 
   * @param id - The UUID of the recommendation to delete
   * @returns Promise resolving to true if successful, false if failed
   */
  async delete(id: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('recommendations')
        .delete()
        .eq('id', id);

      if (error) {
        console.error('Error deleting recommendation:', error);
        throw error;
      }

      return true;
    } catch (error) {
      console.error('Failed to delete recommendation:', error);
      return false;
    }
  },

  /**
   * Deletes all recommendations for a specific domain
   * Use with caution - this is a bulk operation
   * 
   * @param domain - The domain whose recommendations should be deleted
   * @returns Promise resolving to true if successful, false if failed
   */
  async deleteByDomain(domain: string): Promise<boolean> {
    try {
      const { error } = await supabase
        .from('recommendations')
        .delete()
        .eq('domain', domain);

      if (error) {
        console.error('Error deleting recommendations by domain:', error);
        throw error;
      }

      return true;
    } catch (error) {
      console.error('Failed to delete recommendations by domain:', error);
      return false;
    }
  },

  /**
   * Searches recommendations by prompt text using case-insensitive pattern matching
   * Useful for finding recommendations containing specific keywords
   * 
   * @param searchTerm - The text to search for in prompt field
   * @returns Promise resolving to array of matching recommendations or null if failed
   */
  async searchByPrompt(searchTerm: string): Promise<Recommendation[] | null> {
    try {
      const { data, error } = await supabase
        .from('recommendations')
        .select('*')
        .ilike('prompt', `%${searchTerm}%`)     // Case-insensitive LIKE search
        .order('similarity', { ascending: false });

      if (error) {
        console.error('Error searching recommendations:', error);
        throw error;
      }

      return data;
    } catch (error) {
      console.error('Failed to search recommendations:', error);
      return null;
    }
  }
};

/**
 * Export the configured Supabase client for direct use when needed
 * Most operations should use the recommendationsService instead
 */
export default supabase;